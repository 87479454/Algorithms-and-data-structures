# 爬楼梯问题变种
# 题目描述
> 假设你正在爬楼梯，每次你可以爬***1***个、***2***个或***3***个台阶，  
> 那么在***相邻步数不能相同***的条件下，  
> 你有多少种不同的方法可以爬到第n阶呢？
#### 解法：动态规划
+ 类似题型 
  + [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/solution/70-pa-lou-ti-by-alexer-660/)
+ 图解
  + ![截屏2019-11-17上午10.47.49.png](https://pic.leetcode-cn.com/e71f6e89c58e36b7dc3f127ebe2cffa1020936fdf2e36577456efdea683788a2-%E6%88%AA%E5%B1%8F2019-11-17%E4%B8%8A%E5%8D%8810.47.49.png)
+ 思路
  + 去掉限制条件，即此题和**70题**几乎一摸一样
    + 到达第i阶走法有三种
      + ***前1阶走1步***来到终点**或**
        + **如图I 第N-1台阶**，走***1步***来到**end**台阶
          + **如图I 第N-2台阶**，走***1步***来到**N-1**台阶
          + **如图I 第N-3台阶**，走***2步***来到**N-1**台阶
          + **如图I 第N-4台阶**，走***3步***来到**N-1**台阶
            + **依次类推......**
      + ***前2阶走2步***来到终点**或**
        + **如图II 第N-2台阶**，走***2步***来到**end**台阶 
          + **如图II 第N-3台阶**，走***1步***来到**N-2**台阶 
          + **如图II 第N-4台阶**，走***2步***来到**N-2**台阶 
          + **如图II 第N-5台阶**，走***3步***来到**N-2**台阶 
            + **依次类推......**
      + ***前3阶走3步***来到终点
        + **如图III 第N-3台阶**，走***3步***来到**end**台阶
          + **如图III 第N-4台阶**，走***1步***来到**N-3**台阶
          + **如图III 第N-5台阶**，走***2步***来到**N-3**台阶
          + **如图III 第N-6台阶**，走***3步***来到**N-3**台阶
    + 那么走法总数是以上3种情况之和
    + 递推公式：**dp[i] = dp [i-3]+ dp[i-2] + dp[i-1];**
  + 加上限制条件即为本题
    + 意思是如果当前台阶是走n(n=[1,2,3])步来到的
    + 那么它的前一步**不能走相同的n步**
    + 如图I、II、III，就是在当前台阶N-1、N-2、N-3三种情况下，把从左往右第一个绿色的箭头去掉
    + 也就是把上面不加限制条件的三种情况下其中一种情况去掉即可
    + 子问题：
      + dp[i]：从0走到第i阶台阶的走法总数
      + dp[i] = dp [i-3]+ dp[i-2] + dp[i-1];
    + 状态定义：
      + 第i个台阶表示最后一步走n步过来的前i个台阶所用步数总和
        + dp[i][1]：增加维度，二维1代表走到最后一个台阶前一步用了1步
        + dp[i][2]：增加维度，二维2代表走到最后一个台阶前一步用了2步
        + dp[i][3]：增加维度，二维3代表走到最后一个台阶前一步用了3步
    + 边界条件：
      + 走到前一台阶用的步数 ！= 走到当前台阶用的步数
      + 设B[x]代表走到第x级台阶所用步数
        + 则**B[n] != B[n-1]**
      + 合并到状态公式当中去就是
        + **dp[i][n]走法时，dp[i-n][n]走法不能走**
    + 递推公式：
      + **dp[i][1] = dp[i-1][2] + dp[i-1][3]**
      + **dp[i][2] = dp[i-2][1] + dp[i-2][3]**
      + **dp[i][3] = dp[i-3][1] + dp[i-3][2]**
    + 建立状态表：
      + ![截屏2019-11-17下午12.09.15.png](https://pic.leetcode-cn.com/fc32ccec8d45f211a028fe15dca152da7f71b01962658e0848212a03eb3ab728-%E6%88%AA%E5%B1%8F2019-11-17%E4%B8%8B%E5%8D%8812.09.15.png)
      + 结合上述两个图解可知
      ```javascript
      /**
       * @param {number} n
       * @return {number}
       */
      var climbStairs = function(n) {
          if(n < 3){
              return 1;
          }
          var dp = Array.from(new Array(n+1),() => new Array(4).fill(0));
           // 第i级台阶走n步前i个台阶所用步数总和且第i-n台阶不能走
           dp[1][1] = 1;
           dp[2][2] = 1;
           dp[3][1] = 1;
           dp[3][2] = 1;
           dp[3][3] = 1;
           for(var i = 4;i <= n;i++){
               dp[i][1] = dp[i-1][2]+dp[i-1][3];
               dp[i][2] = dp[i-2][1]+dp[i-2][3];
               dp[i][3] = dp[i-3][1]+dp[i-3][2];
           }
           // 合并三种情况
           return dp[n][1] + dp[n][2] + dp[n][3];
       };
      ```